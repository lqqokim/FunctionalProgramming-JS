/**
 * @desc 클로저는 자신이 생성될 때의 스코프에서 할 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.
 * - 상위 스코프의 변수를 사용하고 있지만 a, b가 f1에 의해 사라지지 않으므로 클로저가 아니다.
 * - NodeJS 환경에서는 하나의 JS 파일이 글로벌 영역이 아닌 독립적인 스코프틑 가지기 때문에 a, b가 사라질 수 있으므로 클로자이다.
 * @type {number}
 */

var a = 10;
var b = 20;
function f1() {
    return a + b;
}
console.log(f1()); //30

/**
 * @desc f3 자신이 생성될 때의 스코프가 알고 있는 변수 a, b를 사용하지 않았기 때문애 클로저가 아니다.
 * - 만약 f3이 클로저이면 거의 모든 함수가 클로저일 것이고, 가비지 컬렉터가 메모리를 해제할 수 있는 대상도 없을 것이다.
 * @returns {function(*, *): *}
 */

function f2() {
    var a = 10;
    var b = 20;
    function f3(c, d) {
        return c + d;
    }
    return f3;
}
var f4 = f2();
f4(5, 7); //12

/**
 * @desc f5를 실행하여 리턴하기 떄문에 결국 f5를 조참하고 있는 곳이 어디에도 없으므로 f5는 사라지고, f5가 사라지면 a, b도 사라질 수 있기때문에 클로저는 f4가 실행되는 사이에만 생겼다가 사라진다.
 * @returns {*}
 */

function f4() {
    var a = 10;
    var b = 20;
    function f5() {
        return a + b;
    }
    return f5();
}
f4(); //30

/**
 * @desc 드디어 클로저를 만났다. f7은 클로저이다.
 * - 원래대로라면 f6의 지역 변수는 모두 사라져야 하지만 f6 실행이 끝났어도 f7이 a를 기억하는 클로저가 되었기 때문에 a는 사라지지 않는다.
 * - 여기서도 만약 f6의 실행 결과인 f7을 f8에 담지 않았다면 f7은 클로저가 되지 않는다. (환경을 기억하는 함수를 담은 변수가 필요)
 * @returns {function(*): *}
 */

function f6() {
    var a = 10;
    function f7(b) {
        return a + b;
    }
    return f7;
}
var f8 = f6();
f8(20); //30
f8(10); //20

/**
 * @desc 클로저는 자신이 생성되는 스코프의 실행 컨텍스트에서 만들어졌거나 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하는 함수이다. 클로저가 기억하는 변수의 값은 언제든지 남아니 자신에 의해 변경될 수 있다.
 * - '때'가 함수가 생성이 되는 라인이나 그 이전을 의미하는 것이 아니라 그 스코프가 실행되고 있는 컨텍스트 전체를 말한다.
 * @returns {function(*): *}
 */
function f9() {
    var a = 10;
    var f10 = function(c) {
        return a + b + c;
    };
    var b = 20;
    return f10;
}
var f11 = f9();
f11(30); //60